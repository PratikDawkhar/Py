/// Q 1 ///


--1--

import matplotlib.pyplot as plt
import numpy as np
def f(x):
	return x**2

def g(x):
	return x**3

x = np.linspace(-1, 1, 100)
y_f = f(x)
y_g = g(x)
fig, ax = plt.subplots()
ax.plot(x, y_f, label='f(x) = x^2')
ax.plot(x, y_g, label='g(x) = x^3')
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.legend()
ax.set_title('2D Graph of f(x) = x^2 and g(x) = x^3')
plt.show()


--2--

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
x = np.linspace(-6, 6, 100)
y = np.linspace(-6, 6, 100)
X, Y = np.meshgrid(x, y)
Z = X**2 + Y**2
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(X, Y, Z, cmap='viridis')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Surface Plot of z = x**2 + y**2')
plt.show()


/// Q 2 ///

--1--

def reflect_point(point, line_y):
	x, y = point
	y_reflected = 2 * line_y - y
	return x, y_reflected

A = (1, 0)
D = (2, -1)
C = (-1, 3)
line_y = 3
A_reflected = reflect_point(A, line_y)
D_reflected = reflect_point(D, line_y)
C_reflected = reflect_point(C, line_y)
print("Original Points:")
print("A:", A)
print("D:", D)
print("C:", C)
print("Reflected Points:")
print("A_reflected:", A_reflected)
print("D_reflected:", D_reflected)
print("C_reflected:", C_reflected)


--2--

import numpy as np
A = np.array([0, 0])
B = np.array([4, 0])
C = np.array([3, 3])
AB = np.linalg.norm(B - A)
BC = np.linalg.norm(C - B)
CA = np.linalg.norm(A - C)
s = (AB + BC + CA) / 2
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA))
perimeter = AB + BC + CA
print("Triangle ABC:")
print("Side AB:", AB)
print("Side BC:", BC)
print("Side CA:", CA)
print("Area:", area)
print("Perimeter:", perimeter)


/// Q 3 ///


--A1--

from scipy.optimize import linprog
c = [-5, -3]
A = [[1, 1],[2, 5]]
b = [7, 1]
x_bounds = (0, None)
y_bounds = (0, None)
res = linprog(c, A_ub=A, b_ub=b, bounds=[x_bounds, y_bounds])
if res.success:
	print("Optimal solution found:")
	print("x =", res.x[0])
	print("y =", res.x[1])
	print("Maximum value of Z =", -res.fun)
else:
	print("Optimization failed. Message:", res.message)


--B1--

import math
P = [-2, 4]
shear_y = 7
P_sheared_y = [P[0], P[1] + shear_y]
print("Point after Shearing in Y direction by 7 units:", P_sheared_y)
scale_x_1 = 7/2
scale_y_1 = 7
P_scaled_1 = [P_sheared_y[0] * scale_x_1, P_sheared_y[1] * scale_y_1]
print("Point after Scaling in X- and Y-coordinate by 7/2 and 7 units respectively:", P_scaled_1)
scale_x_2 = 4
scale_y_2 = 7
P_scaled_2 = [P_scaled_1[0] * scale_x_2, P_scaled_1[1] * scale_y_2]
print("Point after Scaling in X- and Y-coordinate by 4 and 7 units respectively:",
P_scaled_2)
angle = 60
angle_rad = math.radians(angle)
P_rotated = [P_scaled_2[0] * math.cos(angle_rad) - P_scaled_2[1] *
math.sin(angle_rad), P_scaled_2[0] * math.sin(angle_rad) + P_scaled_2[1] *
math.cos(angle_rad)]
print("Point after Rotation about origin by an angle of 60 degrees:", P_rotated)




